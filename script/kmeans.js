// Generated by CoffeeScript 1.10.0
(function() {
  var Controller, Core, DataManager, KMeans,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  console.log('K-means clustering');

  DataManager = (function() {
    var _data, _easyUrl, _labels, _loadData, _notEasyUrl, _sendDataToCore, _url;
    _url = null;
    _easyUrl = {
      data: 'data/easyA.csv',
      labels: 'data/easyZ.csv'
    };
    _notEasyUrl = {
      data: 'data/noteasyA.csv',
      labels: 'data/noteasyZ.csv'
    };
    _data = [];
    _labels = [];
    _loadData = function(dataSet) {
      if (dataSet == null) {
        dataSet = 'easy';
      }
      switch (dataSet) {
        case 'easy':
          _url = _easyUrl;
          break;
        case 'not-easy':
          _url = _notEasyUrl;
      }
      return Papa.parse(_url.data, {
        download: true,
        complete: function(dataResults) {
          var ref;
          if (dataResults && ((ref = dataResults.data) != null ? ref.length : void 0) > 0) {
            _data = dataResults.data;
            _data.pop();
            return Papa.parse(_url.labels, {
              download: true,
              complete: function(labelsResults) {
                var ref1;
                if (labelsResults && ((ref1 = labelsResults.data) != null ? ref1.length : void 0) > 0) {
                  _labels = labelsResults.data;
                  _labels.pop();
                  return _sendDataToCore({
                    data: _data,
                    labels: _labels
                  });
                }
              }
            });
          }
        }
      });
    };
    _sendDataToCore = function(data) {
      console.log('DataManager: data loaded');
      console.log(data);
      return Core.fireEvent({
        msg: 'data_loaded',
        data: data
      });
    };
    return {
      loadData: _loadData
    };
  })();

  KMeans = (function() {
    var _arrayEqual, _assignSamples, _distance, _getUniqueLabels, _initCentroids, _initLabels, _matrixMultiply, _runKMeans, _updateMeans, _updatePrecisionMatrix, init;
    _getUniqueLabels = function(labels) {
      return labels.filter(function(x, i, a) {
        return i === a.indexOf(x);
      });
    };
    _distance = function(v1, v2, type, s) {
      var euclidean, mahalanobis, manhattan, max;
      if (type == null) {
        type = 'euclidean';
      }
      if (s == null) {
        s = [];
      }
      euclidean = function(v1, v2) {
        var i, m, ref, total;
        total = 0;
        for (i = m = 0, ref = v1.length - 1; 0 <= ref ? m <= ref : m >= ref; i = 0 <= ref ? ++m : --m) {
          total += Math.pow(v2[i] - v1[i], 2);
        }
        return Math.sqrt(total);
      };
      manhattan = function(v1, v2) {
        var i, m, ref, total;
        total = 0;
        for (i = m = 0, ref = v1.length - 1; 0 <= ref ? m <= ref : m >= ref; i = 0 <= ref ? ++m : --m) {
          total += Math.abs(v2[i] - v1[i]);
        }
        return total;
      };
      max = function(v1, v2) {
        var i, m, ref;
        max = 0;
        for (i = m = 0, ref = v1.length - 1; 0 <= ref ? m <= ref : m >= ref; i = 0 <= ref ? ++m : --m) {
          max = Math.max(max, Math.abs(v2[i] - v1[i]));
        }
        return max;
      };
      mahalanobis = function(v1, v2, s) {
        var diff, el, i, invCov, j, k, l, len, len1, m, o, row, total;
        l = v1.length;
        invCov = s;
        diff = (function() {
          var m, ref, results;
          results = [];
          for (k = m = 0, ref = l - 1; 0 <= ref ? m <= ref : m >= ref; k = 0 <= ref ? ++m : --m) {
            results.push(v1[k] - v2[k]);
          }
          return results;
        })();
        total = 0;
        for (i = m = 0, len = invCov.length; m < len; i = ++m) {
          row = invCov[i];
          for (j = o = 0, len1 = row.length; o < len1; j = ++o) {
            el = row[j];
            total += invCov[i][j] * Math.pow(diff[i], 2 - i - j) * Math.pow(diff[j], i + j);
          }
        }
        return Math.sqrt(total);
      };
      if (_arrayEqual(v1, v2)) {
        return 0;
      } else {
        switch (type.toLowerCase()) {
          case 'manhattan':
            return manhattan(v1, v2);
          case 'max':
            return max(v1, v2);
          case 'mahalanobis':
            return mahalanobis(v1, v2, s);
          default:
            return euclidean(v1, v2);
        }
      }
    };
    _arrayEqual = function(x, y) {
      var a, b;
      a = x.slice().sort();
      b = y.slice().sort();
      return a.length === b.length && a.every(function(elem, i) {
        return elem === b[i];
      });
    };
    _matrixMultiply = function(a, b) {
      var c, col, d1, d2, el, i, j, k, len, len1, m, o, ref, row;
      c = (function() {
        var len, m, ref, results;
        ref = d3.transpose(b);
        results = [];
        for (m = 0, len = ref.length; m < len; m++) {
          d2 = ref[m];
          results.push((function() {
            var len1, o, ref1, results1;
            ref1 = a.length;
            results1 = [];
            for (o = 0, len1 = ref1.length; o < len1; o++) {
              d1 = ref1[o];
              results1.push(0);
            }
            return results1;
          })());
        }
        return results;
      })();
      for (i = m = 0, len = a.length; m < len; i = ++m) {
        row = a[i];
        ref = d3.transpose(b);
        for (j = o = 0, len1 = ref.length; o < len1; j = ++o) {
          col = ref[j];
          c[i][j] = ((function() {
            var len2, p, results;
            results = [];
            for (k = p = 0, len2 = row.length; p < len2; k = ++p) {
              el = row[k];
              results.push(row[k] * col[k]);
            }
            return results;
          })()).reduce(function(t, s) {
            return t + s;
          });
        }
      }
      return c;
    };
    _initCentroids = function(data, k) {
      var centroids, ctr, ctrIdx, m, nRows, ref;
      nRows = data.length;
      centroids = [];
      for (ctr = m = 0, ref = k - 1; 0 <= ref ? m <= ref : m >= ref; ctr = 0 <= ref ? ++m : --m) {
        ctrIdx = Math.floor(Math.random() * nRows);
        if (centroids.length && ctrIdx === !centroids[ctr - 1].idx) {
          ctrIdx = Math.floor(Math.random() * nRows);
        }
        centroids.push({
          val: data[ctrIdx],
          idx: ctrIdx
        });
      }
      return centroids;
    };
    _initLabels = function(l, k) {
      var i, labels, m, ref;
      labels = [];
      for (i = m = 0, ref = l; 0 <= ref ? m <= ref : m >= ref; i = 0 <= ref ? ++m : --m) {
        labels.push(Math.floor(Math.random() * k));
      }
      return labels;
    };
    _updateMeans = function(data, centroids, labels) {
      var col, colMeans, colSums, ctr, ctrData, ctrIdx, distances, el, elIdx, len, len1, len2, len3, len4, m, mean, means, o, p, q, row, rowIdx, u;
      ctrData = (function() {
        var len, m, results;
        results = [];
        for (m = 0, len = centroids.length; m < len; m++) {
          ctr = centroids[m];
          results.push([]);
        }
        return results;
      })();
      for (rowIdx = m = 0, len = data.length; m < len; rowIdx = ++m) {
        row = data[rowIdx];
        ctrData[labels[rowIdx]].push(row);
      }
      means = [];
      for (ctrIdx = o = 0, len1 = ctrData.length; o < len1; ctrIdx = ++o) {
        ctr = ctrData[ctrIdx];
        colSums = (function() {
          var len2, p, ref, results;
          ref = data[0];
          results = [];
          for (p = 0, len2 = ref.length; p < len2; p++) {
            col = ref[p];
            results.push(0);
          }
          return results;
        })();
        for (p = 0, len2 = ctr.length; p < len2; p++) {
          row = ctr[p];
          for (elIdx = q = 0, len3 = row.length; q < len3; elIdx = ++q) {
            el = row[elIdx];
            colSums[elIdx] += el;
          }
        }
        colMeans = colSums.map(function(x) {
          return x / ctr.length;
        });
        means.push(colMeans);
      }
      centroids = [];
      for (u = 0, len4 = means.length; u < len4; u++) {
        mean = means[u];
        distances = (function() {
          var len5, results, v;
          results = [];
          for (v = 0, len5 = data.length; v < len5; v++) {
            row = data[v];
            results.push(_distance(row, mean, 'euclidean'));
          }
          return results;
        })();
        ctrIdx = distances.indexOf(Math.min.apply(this, distances));
        if (indexOf.call(centroids.map(function(x) {
          return x.idx;
        }), ctrIdx) < 0) {
          centroids.push({
            val: data[ctrIdx],
            idx: ctrIdx
          });
        } else {
          distances = distances.splice(ctrIdx);
          ctrIdx = distances.indexOf(Math.min.apply(this, distances));
          centroids.push({
            val: data[ctrIdx],
            idx: ctrIdx
          });
        }
      }
      return centroids;
    };
    _updatePrecisionMatrix = function(data, ctrIdx, labels) {
      var col, cov, covData, e, e1, e2, i, invCov, j, l, len, len1, len2, len3, len4, len5, m, matrix, matrixT, means, n, o, p, q, ref, row, tCov, tCovInv, u, v, w;
      matrix = [];
      for (i = m = 0, ref = data.length; 0 <= ref ? m <= ref : m >= ref; i = 0 <= ref ? ++m : --m) {
        if (labels[i] === ctrIdx) {
          matrix.push(data[i].slice());
        }
      }
      n = matrix.length;
      matrixT = d3.transpose(matrix);
      l = matrixT.length;
      means = (function() {
        var len, o, results;
        results = [];
        for (o = 0, len = matrixT.length; o < len; o++) {
          col = matrixT[o];
          results.push(col.reduce(function(t, s) {
            return t + s;
          }) / n);
        }
        return results;
      })();
      for (i = o = 0, len = matrix.length; o < len; i = ++o) {
        row = matrix[i];
        for (j = p = 0, len1 = row.length; p < len1; j = ++p) {
          col = row[j];
          matrix[i][j] = col - means[j];
        }
      }
      matrixT = d3.transpose(matrix);
      cov = (function() {
        var q, ref1, results;
        results = [];
        for (e2 = q = 0, ref1 = l - 1; 0 <= ref1 ? q <= ref1 : q >= ref1; e2 = 0 <= ref1 ? ++q : --q) {
          results.push((function() {
            var ref2, results1, u;
            results1 = [];
            for (e1 = u = 0, ref2 = l - 1; 0 <= ref2 ? u <= ref2 : u >= ref2; e1 = 0 <= ref2 ? ++u : --u) {
              results1.push(0);
            }
            return results1;
          })());
        }
        return results;
      })();
      cov = _matrixMultiply(matrixT, matrix);
      cov = cov.map(function(row) {
        return row.map(function(el) {
          return el / (n - 1);
        });
      });
      tCov = new jsfeat.matrix_t(l, l, jsfeat.F32_t | jsfeat.C1_t);
      covData = [];
      for (q = 0, len2 = cov.length; q < len2; q++) {
        row = cov[q];
        for (u = 0, len3 = row.length; u < len3; u++) {
          e = row[u];
          covData.push(e);
        }
      }
      tCov.data = covData;
      tCovInv = new jsfeat.matrix_t(l, l, jsfeat.F32_t | jsfeat.C1_t);
      jsfeat.linalg.svd_invert(tCovInv, tCov);
      invCov = (function() {
        var ref1, results, v;
        results = [];
        for (e2 = v = 0, ref1 = l - 1; 0 <= ref1 ? v <= ref1 : v >= ref1; e2 = 0 <= ref1 ? ++v : --v) {
          results.push((function() {
            var ref2, results1, w;
            results1 = [];
            for (e1 = w = 0, ref2 = l - 1; 0 <= ref2 ? w <= ref2 : w >= ref2; e1 = 0 <= ref2 ? ++w : --w) {
              results1.push(0);
            }
            return results1;
          })());
        }
        return results;
      })();
      for (i = v = 0, len4 = invCov.length; v < len4; i = ++v) {
        row = invCov[i];
        for (j = w = 0, len5 = row.length; w < len5; j = ++w) {
          col = row[j];
          invCov[i][j] = tCovInv.data[2 * i + j];
        }
      }
      return invCov;
    };
    _assignSamples = function(data, centroids, distanceType) {
      var ctr, distances, labels, len, m, row;
      labels = [];
      for (m = 0, len = data.length; m < len; m++) {
        row = data[m];
        distances = (function() {
          var len1, o, results;
          results = [];
          for (o = 0, len1 = centroids.length; o < len1; o++) {
            ctr = centroids[o];
            results.push(_distance(row, ctr.val, distanceType));
          }
          return results;
        })();
        labels.push(distances.indexOf(Math.min.apply(this, distances)));
      }
      return labels;
    };
    _runKMeans = function(data, trueLabels, k, maxIter, centroids, distanceType, uniqueLabels, computeAcc) {
      var covMats, ctr, ctrIdx, evaluateAccuracy, interval, labels, lbls, len, m, run, runMahalanobis, step;
      evaluateAccuracy = function(labels, trueLabels, uniqueLabels) {
        var acc, accK, accs, i, kLabelIdxs, kLabels, kTrueLabels, len, m, x;
        accs = [0];
        for (m = 0, len = uniqueLabels.length; m < len; m++) {
          k = uniqueLabels[m];
          kLabelIdxs = (function() {
            var len1, o, results;
            results = [];
            for (i = o = 0, len1 = trueLabels.length; o < len1; i = ++o) {
              x = trueLabels[i];
              if (x === k) {
                results.push(i);
              }
            }
            return results;
          })();
          kLabels = (function() {
            var len1, o, results;
            results = [];
            for (i = o = 0, len1 = labels.length; o < len1; i = ++o) {
              x = labels[i];
              if (indexOf.call(kLabelIdxs, i) >= 0) {
                results.push(x);
              }
            }
            return results;
          })();
          kTrueLabels = (function() {
            var len1, o, results;
            results = [];
            for (o = 0, len1 = trueLabels.length; o < len1; o++) {
              x = trueLabels[o];
              if (x === k) {
                results.push(x);
              }
            }
            return results;
          })();
          accK = kLabels.map(function(x, idx) {
            return x - kTrueLabels[idx];
          }).reduce(function(r, s) {
            return r + s;
          });
          accs.push(Math.abs(accK));
        }
        acc = (trueLabels.length - accs.reduce(function(r, s) {
          return r + s;
        })) / trueLabels.length;
        return acc = acc < 0.5 ? 1 - acc : acc;
      };
      step = function(data, centroids, trueLabels) {
        var labels, means;
        maxIter--;
        console.log('Iteration: ' + maxIter);
        console.log('Centroids: ');
        console.table(centroids);
        labels = _assignSamples(data, centroids, distanceType);
        means = _updateMeans(data, centroids, labels);
        console.log('New means: ');
        console.table(means);
        if (!_arrayEqual(means.map(function(x) {
          return x.idx;
        }), centroids.map(function(x) {
          return x.idx;
        }))) {
          centroids = means;
          Controller.redraw(data, means.map(function(x) {
            return x.val;
          }), labels);
        } else {
          maxIter = 0;
        }
        return {
          centroids: centroids,
          labels: labels
        };
      };
      run = function() {
        var acc, labels, res;
        if (maxIter) {
          res = step(data, centroids, trueLabels);
          centroids = res.centroids;
          return labels = res.labels;
        } else {
          clearInterval(interval);
          console.log('K-Means done.');
          if (computeAcc) {
            labels = _assignSamples(data, centroids, distanceType);
            acc = evaluateAccuracy(labels, trueLabels, uniqueLabels);
            console.log('Accuracy: ' + acc * 100 + '%');
          } else {
            acc = '';
          }
          return Core.fireEvent({
            msg: 'kmeans_done',
            data: acc * 100
          });
        }
      };
      runMahalanobis = function() {
        var acc, ctr, ctrDistances, ctrIdx, i, j, len, len1, m, means, o, row;
        if (maxIter) {
          maxIter--;
          console.log('Iteration: ' + maxIter);
          console.log('Centroids: ');
          console.table(centroids);
          means = centroids.slice();
          for (i = m = 0, len = data.length; m < len; i = ++m) {
            row = data[i];
            ctrDistances = (function() {
              var len1, o, results;
              results = [];
              for (j = o = 0, len1 = centroids.length; o < len1; j = ++o) {
                ctr = centroids[j];
                results.push(_distance(row, ctr.val, distanceType, covMats[j]));
              }
              return results;
            })();
            ctrIdx = ctrDistances.indexOf(Math.min.apply(this, ctrDistances));
            if (ctrIdx !== lbls[i]) {
              lbls[i] = ctrIdx;
              centroids = _updateMeans(data, centroids, lbls);
              Controller.redraw(data, centroids.map(function(x) {
                return x.val;
              }), lbls);
              for (j = o = 0, len1 = centroids.length; o < len1; j = ++o) {
                ctr = centroids[j];
                covMats[j] = _updatePrecisionMatrix(data, j, lbls);
              }
            }
          }
          if (_arrayEqual(means.map(function(x) {
            return x.idx;
          }), centroids.map(function(x) {
            return x.idx;
          }))) {
            return maxIter = 0;
          }
        } else {
          clearInterval(interval);
          console.log('K-Means done.');
          if (computeAcc) {
            acc = evaluateAccuracy(lbls, trueLabels, uniqueLabels);
            console.log('Accuracy: ' + acc * 100 + '%');
          } else {
            acc = '';
          }
          return Core.fireEvent({
            msg: 'kmeans_done',
            data: acc * 100
          });
        }
      };
      if (distanceType === 'mahalanobis') {
        labels = _assignSamples(data, centroids, 'euclidean');
        centroids = _updateMeans(data, centroids, labels);
        covMats = [];
        lbls = labels.slice();
        for (ctrIdx = m = 0, len = centroids.length; m < len; ctrIdx = ++m) {
          ctr = centroids[ctrIdx];
          covMats.push(_updatePrecisionMatrix(data, ctrIdx, labels));
        }
        return interval = setInterval(runMahalanobis, 1000);
      } else {
        return interval = setInterval(run, 1000);
      }
    };
    init = function(obj, k, maxIter) {
      var centroids, computeAcc, data, distanceType, initLabels, initMethod, labels, row, uniqueLabels;
      if (maxIter == null) {
        maxIter = 20;
      }
      data = obj.data;
      data = (function() {
        var len, m, results;
        results = [];
        for (m = 0, len = data.length; m < len; m++) {
          row = data[m];
          results.push(row.map(Number));
        }
        return results;
      })();
      labels = obj.labels;
      labels = labels.map(function(x) {
        return Number(x[0]);
      });
      computeAcc = true;
      distanceType = Controller.getDistanceType();
      uniqueLabels = _getUniqueLabels(labels);
      k = Number(k);
      console.log('K: ' + k);
      if (k !== 2) {
        computeAcc = false;
      }
      Controller.drawDataPoints(data);
      initMethod = Controller.getInitMethod();
      if (initMethod === 'forgy') {
        centroids = _initCentroids(data, k);
        initLabels = _assignSamples(data, centroids, 'euclidean');
      } else {
        initLabels = _initLabels(data.length - 1, k);
        centroids = _updateMeans(data, uniqueLabels, initLabels);
      }
      Controller.redraw(data, centroids.map(function(x) {
        return x.val;
      }), initLabels);
      console.log('Starting K-Means');
      return _runKMeans(data, labels, k, maxIter, centroids, distanceType, uniqueLabels, computeAcc);
    };
    return {
      run: init
    };
  })();

  Controller = (function() {
    var _clearChart, _color, _drawDataPoints, _getDataset, _getDistanceType, _getInitMethod, _getKValue, _graph, _initChart, _meanLayer, _publishResult, _redraw, _setStartButtonListener, _xScale, _yScale;
    _graph = null;
    _xScale = null;
    _yScale = null;
    _color = null;
    _meanLayer = null;
    _getDistanceType = function() {
      return $('.distInput input:radio:checked').val();
    };
    _getDataset = function() {
      return $('.dataInput input:radio:checked').val();
    };
    _getInitMethod = function() {
      return $('.initInput input:radio:checked').val();
    };
    _getKValue = function() {
      return $('.kInput select').val();
    };
    _setStartButtonListener = function(func) {
      return $('.runKMeans').click(function() {
        event.preventDefault();
        _clearChart();
        return func();
      });
    };
    _drawDataPoints = function(dataPoints) {
      var pointDots;
      pointDots = _graph.selectAll('.pointDots').data(dataPoints);
      return pointDots.enter().append('circle').attr('class', 'pointDots').attr('r', 3).attr('cx', function(d) {
        return _xScale(d[0]);
      }).attr('cy', function(d) {
        return _yScale(d[1]);
      });
    };
    _clearChart = function() {
      _graph.selectAll('.pointDots').remove();
      return _graph.selectAll('g > g > *').remove();
    };
    _redraw = function(dataPoints, means, assignments) {
      var assignmentLines, meanDots;
      assignmentLines = _meanLayer.selectAll('.assignmentLines').data(assignments);
      assignmentLines.enter().append('line').attr('class', 'assignmentLines').attr('x1', function(d, i) {
        return _xScale(dataPoints[i][0]);
      }).attr('y1', function(d, i) {
        return _yScale(dataPoints[i][1]);
      }).attr('x2', function(d, i) {
        return _xScale(means[d][0]);
      }).attr('y2', function(d, i) {
        return _yScale(means[d][1]);
      }).attr('stroke', function(d) {
        return _color(d);
      });
      assignmentLines.transition().duration(500).attr('x2', function(d, i) {
        return _xScale(means[d][0]);
      }).attr('y2', function(d, i) {
        return _yScale(means[d][1]);
      }).attr('stroke', function(d) {
        return _color(d);
      });
      meanDots = _meanLayer.selectAll('.meanDots').data(means);
      meanDots.enter().append('circle').attr('class', 'meanDots').attr('r', 5).attr('stroke', function(d, i) {
        return _color(i);
      }).attr('stroke-width', 3).attr('fill', 'white').attr('cx', function(d) {
        return _xScale(d[0]);
      }).attr('cy', function(d) {
        return _yScale(d[1]);
      });
      meanDots.transition().duration(500).attr('cx', function(d) {
        return _xScale(d[0]);
      }).attr('cy', function(d) {
        return _yScale(d[1]);
      });
      return meanDots.exit().remove();
    };
    _publishResult = function(data) {
      return $('.kMeansAcc').text(data + '%');
    };
    _initChart = function() {
      var svg;
      svg = d3.select('#chart').append('svg').attr('width', 1200).attr('height', 700);
      _graph = svg.append('g').attr('transform', 'translate(350,350)');
      _meanLayer = _graph.append('g');
      _xScale = d3.scale.linear().domain([0, 10]).range([0, 300]);
      _yScale = d3.scale.linear().domain([0, 10]).range([0, 300]);
      return _color = d3.scale.category10();
    };
    return {
      getDistanceType: _getDistanceType,
      getDataset: _getDataset,
      getInitMethod: _getInitMethod,
      getKValue: _getKValue,
      setStartButtonListener: _setStartButtonListener,
      drawDataPoints: _drawDataPoints,
      publishResult: _publishResult,
      initChart: _initChart,
      redraw: _redraw
    };
  })();

  Core = (function() {
    var _api, _getData, _init, _start, _startKMeans;
    _start = function() {
      Controller.setStartButtonListener(_getData);
      Controller.initChart();
      return _getData();
    };
    _getData = function() {
      var dataset;
      dataset = Controller.getDataset();
      DataManager.loadData(dataset);
      return console.log('Dataset selected: ' + dataset);
    };
    _startKMeans = function(data) {
      var k;
      k = Controller.getKValue();
      return KMeans.run(data, k);
    };
    _api = function(ev) {
      if ((ev != null) & (ev.msg != null) & (ev.data != null)) {
        switch (ev.msg) {
          case 'data_loaded':
            return _startKMeans(ev.data);
          case 'kmeans_done':
            return Controller.publishResult(ev.data);
          default:
            return console.log('Unknown message: ' + ev.msg);
        }
      } else {
        return false;
      }
    };
    _init = function() {
      console.log('Core init');
      return _start();
    };
    return {
      init: _init,
      fireEvent: _api
    };
  })();

  return {
    start: Core.init()
  };

}).call(this);

//# sourceMappingURL=kmeans.js.map
